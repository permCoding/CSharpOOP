## Значение null  

Источник: https://metanit.com/sharp/tutorial/3.26.php  

Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать значение null. Например:

```
object o = null;
string s = null;
```

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null. Фактически оно говорит об отстутсвии значения как такового.  

Но типы значений, например, int, decimal, double и т.д. не могут принимать значение null.  

### Оператор ??

Оператор ?? называется оператором null-объединения. Он применяется для установки значений по умолчанию для типов, которые допускают значение null. Оператор ?? возвращает левый операнд, если этот операнд не равен null. Иначе возвращается правый операнд. При этом левый операнд должен принимать null. Посмотрим на примере:

```
object x = null;
object y = x ?? 100;  // равно 100, так как x равен null
 
object z = 200;
object t = z ?? 44; // равно 200, так как z не равен null
```

Но мы не можем написать следующим образом:

```
int x = 44;
int y = x ?? 100;
```

Здесь переменная x представляет значимый тип int и не может принимать значение null, поэтому в качестве левого операнда в операции ?? она использоваться не может.

### Оператор условного null

Иногда при работе с объектами, которые принимают значение null, мы можем столкнуться с ошибкой: мы пытаемся обратиться к объекту, а этот объект равен null. Например, пусть у нас есть следующая система классов:

```
class User
{
    public Phone Phone { get; set; }
} 
class Phone
{
    public Company Company { get; set; }
}
class Company
{
    public string Name { get; set; }
}
```

Объект User содержит ссылку на объект Phone, а объект Phone содержит ссылку на объект Company, поэтому теоретически мы можем получить из объекта User название компании, например, так:

```
User user = new User();
Console.WriteLine(user.Phone.Company.Name);
```

В данном случае свойство Phone не определено, будет по умолчанию иметь значение null. Поэтому мы столкнемся с исключением NullReferenceException. Чтобы избежать этой ошибки мы могли бы использовать условную конструкцию для проверки на null:

```
User user = new User();
 
if(user!=null)
{
    if(user.Phone!=null)
    {
        if (user.Phone.Company != null)
        {
            string companyName = user.Phone.Company.Name;
            Console.WriteLine(companyName);
        }
    }
}
```

Получается многоэтажная конструкция, но на самом деле ее можно сократить:

```
if(user!=null && user.Phone!=null && user.Phone.Company!=null)
{
    string companyName = user.Phone.Company.Name;
    Console.WriteLine(companyName);
}
```

Если user не равно null, то проверяется следующее выражение user.Phone!=null и так далее. Конструкция намного проще, но все равно получается довольно большой. И чтобы ее упростить, в C# оператор условного null (Null-Conditional Operator):

```
string companyName = user?.Phone?.Company?.Name;
```

Выражение ?. и представляет оператор условного null. Здесь последовательно проверяется равен ли объект user и вложенные объекты значению null. Если же на каком-то этапе один из объектов окажется равным null, то companyName будет иметь значение по умолчанию, то есть null.

И в этом случае мы можем пойти дальше и применить операцию ?? для установки значения по умолчанию, если название компании не установлено:

```
User user = new User();
string companyName = user?.Phone?.Company?.Name ?? "не установлено";
Console.WriteLine(companyName);
```

---  
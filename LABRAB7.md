## LABRAB 7 - дедлайн 18.12.2020 24:00  
## дата занятия 12.12.2020  
### Полиморфизм  

**Теория**  

Три вида полиморфизма...  

Полиморфизм (в широкой трактовке) - это возможность менять реализацию программного кода в зависимости от текущих условий.  

В зависимости от точки зрения можно выделить три вида полиморфизма:  
1) полиморфизм методов,  
2) полиморфизм конструкторов,  
3) полиморфизм объектов.  

Полиморфизм методов ещё называют **статическим полиморфизмом** или полиморфизмом раннего связывания - это означает, что ещё на этапе компиляции будет понятно как именно будет реализован тот или иной метод (что определяется сигнатурой метода).  

Полиморфизм конструкторов - это возможность выбрать конструктор в зависимости от сигнатуры - обычно просто называют **перегрузкой конструкторов**.  

Полиморфизм объектов ещё называют **динамическим полиморфизмом** или полиморфизмом позднего связывания - это означает, что только на этапе исполнения программного кода будет понятно как именно будет реализован тот или иной метод объекта. Подразумевается, что в базовом классе определён виртуальный метод, а в классах наследниках он переопределён и только в момент исполнения программы будет понятно какой именно метод (virtual или override) будет вызван на исполнение.  

Часто под полиморфизмом понимают исключительно динамический полиморфизм.  

Рассмотрим примеры.  

**1. Полиморфизм методов**  
Обратите внимание: в классе Poly методы имеют одинаковое наименование, но различаются по сигнатуре.  
В зависимости от типов подаваемых аргументов компилятор будет выбирать какой именно из методов подключать.  

```
using System;

namespace Polymorp
{
    class Poly
    {   
        public static int get(int a, int b)
        {
            return a + b;
        }
        public static double get(double a, double b)
        {
            return a + b;
        }
        public static string get(string a, string b)
        {
            return a + b;
        }
    }
    class Program
    {
        static void Main()
        {
            Console.WriteLine(Poly.get(1, 2)); // целые числа
            Console.WriteLine(Poly.get(1.1, 2.2)); // вещественные числа
            Console.WriteLine(Poly.get("1", "2")); // строки

            Console.ReadLine();
        }
    }
}
```

**2. Полиморфизм конструкторов**  
Обратите внимание, что в классе Poly определены три конструктора, каждый отличается сигнатурой.  
А в коде метода Main мы создаём три объекта с использованием разных конструкторов.  
Предполагается, что создаётся некий объект с начальной позицией и обладающий некоторой скоростью.  
Метод Moving обеспечивает изменение позиции объекта с определённой скоростью.  

Таким образом, можно обеспечить гибкость создания объектов.  

```
using System;

namespace Polymorp
{
    class Poly
    {
        public int Pos { get; set; }
        public int Velocity { get; set; }
        public Poly()
        {
            Pos = 0;
            Velocity = 0;
        }
        public Poly(int velocity)
        {
            Pos = 0;
            Velocity = velocity;
        }
        public Poly(int pos = 0, int velocity = 10)
        {
            Pos = pos;
            Velocity = velocity;
        }
        public void Moving()
        {
            Pos += Velocity;
        }
    }
    class Program
    {
        static void Main()
        {
            // полиморфизм конструкторов
            Poly obj1 = new Poly();
            Poly obj2 = new Poly(5);
            Poly obj3 = new Poly(0, 8);
            obj1.Moving();
            obj2.Moving();
            obj3.Moving();

            Console.WriteLine(obj1.Pos);
            Console.WriteLine(obj2.Pos);
            Console.WriteLine(obj3.Pos);

            Console.ReadLine();
        }
    }
}
```

**3. Полиморфизм объектов**  
Обратите внимание, что в примере есть базовый класс Animal (живое существо).  
От него наследуются классы Ork и Human.  
В базовом классе определены:  
~ позиция  
~ метод движения (на 1 шаг)  
~ метод печати (выводит позицию)  

Методы Moving и Print определены как виртуальные - это значит, что в классах наследниках их можно переопределить.  

В наследуемом классе Ork инициализация позиции реализована через конструктор базового класса.  
В наследуемом классе Ork переопределены методы Moving (движется заметно быстрее) и Print (пишет, что это именно Ork).  

В наследуемом классе Human инициализация позиции реализована через конструктор базового класса.  
В наследуемом классе Human есть дополнительное свойство Name (у каждого человека есть имя, у животных и орков - нет).  
В наследуемом классе Human переопределен только метод Print (пишет имя человека).  

Таким образом, наследование в сочетании с полиморфизмом позволяет общие методы содержать в базовом классе, а в наследниках добавлять или изменять функционал.  

```
using System;
using System.Collections.Generic;

namespace Polymorp
{
    class Animal
    {
        public int Pos { get; set; }
        public Animal(int pos)
        {
            Pos = pos;
        }
        public virtual void Moving()
        {
            ++Pos;
        }
        public virtual void Print()
        {
            Console.WriteLine($"Animal position - {Pos}");
        }
    }
    class Ork : Animal
    {
        public Ork(int pos): base(pos)
        {
        }
        public override void Moving()
        {
            Pos += 10;
        }
        public override void Print()
        {
            Console.WriteLine($"Ork position - {Pos}");
        }
    }
    class Human : Animal
    {
        public string Name { get; set; }
        public Human(int pos, string name): base(pos)
        {
            this.Name = name;
        }
        public override void Print()
        {
            Console.WriteLine($"{Name} position - {Pos}");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // полиморфизм объектов
            List<Animal> animals = new List<Animal>() {
                new Animal(0),
                new Ork(0),
                new Human(0, "Mando")
            };

            foreach (Animal animal in animals)
            {
                animal.Moving();
                animal.Print();
            }

            Console.ReadLine();
        }
    }
}
```
Будет такой вывод в консоль:  
```
Animal position - 1
Ork position - 10
Mando position - 1
```

В дальнейшем мы под полиморфизмом будем понимать именно динамический полиморфизм.  

**Дополнительно**: Главы из учебника - https://pcoding.ru/pdf/CSharpOOP.pdf  

---  

**Техническое задание**  

Написать **консольное** приложение.  
**Шахматные фигуры**  

По аналогии с проектом **Interface1**  
[Запись лекции про интерфейсы](https://bbb.psaa.ru/playback/presentation/2.0/playback.html?meetingId=69e8849d5a716b1ee72ac4cf4bfe7edeb835a901-1606812569941)  

Есть список шахматных фигур чёрного цвета и их позиций на доске. Нужно проверить: можно ли в определённую ячейку поставить белую фигуру (то есть находится это поле под боем или нет)?  

Исходные данные о фигурах вводятся из входного текстового файла **input.txt** - в каждой строке новая фигура. Формат записи такой - название, пробел, позиция. Есть два вида фигур:  
- Конь (Horse)  
- Ладья (Rook)  

Они кодируются символами H и R, соответственно. Вот пример входного файла:  
```
H C4
R F3
H E2
```
После запуска программы пользователь вводит в консоли с клавиатуры адрес ячейки в формате (буква, цифра), например: E4 (буквы меняются от A до H, цифры от 1 до 8).  

![chess-placement.jpg](https://github.com/permCoding/CSharpOOP/blob/master/images/chess-placement.jpg)  

Программа должна проверить возможности ходов всех чёрных фигур и вывести true, если белую фигуру можно поставить в обозначенное поле и false, если нельзя. Для обозначенной выше позиции корректный ответ **true**.  

**УПРОЩЕНИЕ** в логике работы: для ладьи все фигуры прозрачные, то есть можно не учитывать наличие других фигур на доске когда вычисляете какие поля бьёт Ладья - Ладья всегда бьёт на всю ширину доски по горизонтали и на всю высоту по вертикали независимо есть на пути препятствующие фигуры или нет.  

---  

**Архитектура программы.**  

Создайте:  
В отдельном файле **Интерфейс** для классов шахматных фигур IFigure  
В отдельном файле **Классы**: Horse, Rook  
В программе **диалог** с пользователем: ввод позиции белой фигуры - вывод ответа.  

Интерфейс декларирует:  
- свойство string Name  
- свойство string Pos  
- метод bool CheckPos(string pos)  

Свойство Name - это наименование чёрной фигуры - Horse или Rook  
Свойство Pos - это координата чёрной фигуры, например: F3  
Метод CheckPos на вход получает позицию белой фигуры, а на выход возвращает true (если на поле можно ставить белую фигуры) или false (нельзя ставить белую фигуру).  

В классах должны быть ***конструкторы*** с инициализацией свойств Name и Pos.  

---  
